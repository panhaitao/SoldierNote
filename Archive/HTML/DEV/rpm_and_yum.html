<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>RPM包与YUM仓库</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">RPM包与YUM仓库</h1>
</header>
<h2 id="什么是rpm">什么是RPM</h2>
<p>RPM包源自于Red Hat Linux 分发版，是Linux下常见的软件包格式之一，RPM包有两种包格式：</p>
<pre><code>扩展名为 .rpm     封装完成的RPM二进制安装包
扩展名为 .src.rpm 包含编译控制文件的SRPM源码包</code></pre>
<h2 id="同步yum仓库">同步yum仓库</h2>
<p>/etc/yum.repos.d/centos-6.8.repo</p>
<pre><code>[centos6.8-64]
name=centos 6.8 x86-64
baseurl=http://vault.centos.org/6.8/os/x86_64/
enabled=1
priority=1</code></pre>
<p><code>yum repolist</code>,列出当前的配置中的仓库，输出如下：</p>
<pre><code>repo id         repo name               status
centos6.8       centos 6.8 x86-64        6,696
repolist: 6,696</code></pre>
<p>使用reposync工具同步仓库，参考操作如下<code>reposync -m &lt;repo id&gt;</code></p>
<h2 id="构建-rpm-软件包">构建 RPM 软件包</h2>
<ul>
<li>准备工作环境</li>
<li>系统中安装好 rpmbuild 打包工具</li>
<li>编写一个扩展名为 .spec 文件，该文件指导 rpmbuild 命令如何构建和打包软件。这个文件可以任意地给它命名并把它放到任何地方，RPM对此没有限制。</li>
</ul>
<p>修改上游源码包，获取上游SRPM包，将其解压到工作目录<code>rpm -ivh http://mirrors.ustc.edu.cn/fedora/releases/22/Server/source/SRPMS/b/bc-1.06.95-13.fc22.src.rpm</code> 解压后,会把srpm包解压到 ~/rpmbuild/ 目录，其中：</p>
<ul>
<li>spec文件解压到 ~/rpmbuild/SPECS/ 目录中</li>
<li>补丁和源码解压到 ~/rpmbuild/SOURCES/ 目录中</li>
</ul>
<p>重新编译源码包<code>rpmbuild -ba ~/rpmbuild/SPECS/bc.spec</code> 编译完成后，结果会存放在 ~/rpmbuild/SRPM/ ~/rpmbuild/RPM/ 目录中，在这里需要了解一下rpm的环境变量，查看rpm的环境变量 rpm --showrc ，其中 _topdir 定义了工作目录位置，默认是 $HOME/rpmbuild/，该目录下有五个目录：</p>
<pre><code>SPECS       放置 .spec 文件
SOURCES     放置套件的源码及补丁等
BUILD       用于存放解后压合并布补丁的源码目录
BUILDROOT   用于存放封装生成的 RPM 安装包的文件
RPMS        放置二进制 RPM 安装包 (.rpm)
SRPMS       放置源码格式的 RPM包 (.src.rpm)</code></pre>
<p>下面总结了在您运行 rpm -ba filename.spec 时，RPM 都做些什么：</p>
<pre><code>读取并解析 filename.spec 文件
运行 %prep 部分来将源代码解包一个临时目录 (~/rpmbuild/BUILD/XXXX)，并应用所有的补丁程序
运行 %build 部分来编译代码
运行 %install 部分将代码安装到一个临时目录（~/rpmbuild/BUILDROOT/XXXX）
读取 %files 部分的文件列表，收集文件并创建二进制和源 RPM 文件。
运行 %clean 部分清楚临时构建目录</code></pre>
<h2 id="创建仓库">创建仓库</h2>
<p>yum主要用于自动安装、升级rpm软件包，它能自动查找并解决rpm包之间的依赖关系。使用yum就需要有添加一个包含各种rpm软件包的repository（软件仓库），这个软件仓库我们习惯称为yum源，下面我们就讲述如何创建自定义的软件仓库。 创建仓库执行命令 <code>yum install createrepo -y</code>，安装一个名为createrepo的软件包，然后使用createrepo就可以完成yum仓库的创建，示例如下：</p>
<p>createrepo -g dvd-comps.xml -u Packages/ /repo</p>
<pre><code>-g dvd-comps.xml        指定分组配置文件
-u Packages/            使用Packages/ 这个rpm包存放目录
/repo                   仓库根目录， 默认生成的索引文件存放在这个目录下</code></pre>
<p>各个版本软件分组参考可以从这里获取 ：<code>git clone git://git.fedorahosted.org/git/comps.git</code></p>
<h2 id="更新仓库">更新仓库</h2>
<p>在一个已创建好的yum仓库目录下，添加或删除rpm包后，使用 –update 参数就可以完成仓库的更新 <code>createrepo -g dvd-comps.xml -u Packages/ --update /repo</code></p>
<p>在创建好的yum仓库目录下会创建repodata目录，里面存放XML格式或sqlite数据库的仓库索引文件，执行命令yum update，就是在同步yum源的索引，下面是repodata索引部分的概述：</p>
<pre><code>repomd.xml                   描述的其他元数据文件的文件
primary.[xml/sqlite].[gz]    主要元数据信息文件，记录软件包报名,版本，预配置文件，依赖关系等
filelists.[xml/sqlite].[gz]  软件包文件，目录列表描述信息
other.[xml/sqlite].[gz]      目前只记录存储数据的变更记录
comps.xml.[gz]               用于记录软件包组分类等信息(需要创建仓库的时候指定分组文件)</code></pre>
<p>更多细节可参考文档 http://createrepo.baseurl.org/</p>
<h2 id="添加软件源">添加软件源</h2>
<p>以上文提到的创建好的yum的软件仓库为例，添加一个软件源. yum仓库配置文件扩展名是 .repo, 创建配置文件：/etc/yum.repos.d/local.repo</p>
<pre><code>[local]
name=local
baseurl=file:///repo/
gpgcheck=0</code></pre>
<p>重新执行命令yum update之后就可以使用这个软件仓库了。</p>
<h2 id="repo文件格式">repo文件格式</h2>
<p>所有 repository 服务器设置都遵循如下格式：</p>
<pre><code>[serverid]
name=Some name for this server
baseurl=url://path/to/repository/
其他可选配置</code></pre>
<ul>
<li>serverid 是用于区分不同的 repository ，必须有一个独一无二的名称；</li>
<li>name 是对 repository 的描述部分</li>
<li><p>baseurl 是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。它的格式是：</p>
<pre><code>baseurl=url://server1/path/to/repository/
　　　   url://server2/path/to/repository/
　　　   url://server3/path/to/repository/</code></pre></li>
</ul>
<p>其中url 支持的协议有http:// ftp:// file://三种。baseurl 后可以跟多个url，</p>
<ul>
<li>一个 repo 文件可以添加多个repository配置</li>
<li>一个 repository 配置中只能有一个baseurl</li>
<li>其中 url 指向的目录必须是这个repository 索引目录所在的根目录</li>
</ul>
<h2 id="打包辅助工具">打包辅助工具</h2>
<p>实际开发过程中必须模拟用户的环境或是构建一个“干净”的环境（一个仅仅满足编译构建的最小系统环境）使用mock命令就达到在一个“干净”的环境重新编译构建。</p>
<p>安装软件包： <code>yum install mock -y</code></p>
<p>使用 mock 工具编译软件包，需要在yum仓库中建立了一个sysbuild分组，该分组包含了一个最小化系统所需的基础软件包。以下是 comps.xml 参考：</p>
<pre><code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;
&lt;!DOCTYPE comps PUBLIC &quot;-//CentOS//DTD Comps info//EN&quot; &quot;comps.dtd&quot;&gt;
&lt;comps&gt;
  &lt;group&gt;
    &lt;id&gt;sysbuild&lt;/id&gt;
    &lt;name&gt;mock build base group&lt;/name&gt;
    &lt;name xml:lang=&quot;zh_CN&quot;&gt;自动编译基础系统&lt;/name&gt;
    &lt;name xml:lang=&quot;zh_TW&quot;&gt;自动编译基础系统&lt;/name&gt;
    &lt;description&gt;mock build base group&lt;/description&gt;
    &lt;description xml:lang=&quot;zh_CN&quot;&gt;自动编译基础系统&lt;/description&gt;
    &lt;description xml:lang=&quot;zh_TW&quot;&gt;自动编译基础系统&lt;/description&gt;
    &lt;default&gt;false&lt;/default&gt;
    &lt;uservisible&gt;true&lt;/uservisible&gt;
    &lt;packagelist&gt;
        &lt;packagereq type=&quot;default&quot;&gt;bash&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;gawk&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;rpm&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;rpm-build&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;bzip2&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;gcc&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;sed&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;coreutils&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;git&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;deepin-release&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;tar&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;cpio&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;gnupg2&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;texinfo&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;curl&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;grep&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;unzip&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;diffutils&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;gzip&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;redhat-rpm-config&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;util-linux-ng&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;findutils&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;make&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;patch&lt;/packagereq&gt;
        &lt;packagereq type=&quot;default&quot;&gt;which&lt;/packagereq&gt;
    &lt;/packagelist&gt;
  &lt;/group&gt;
  &lt;category&gt;
    &lt;id&gt;sysbuild&lt;/id&gt;
    &lt;name&gt;sysbuild&lt;/name&gt;
    &lt;description&gt;mock mini require&lt;/description&gt;
    &lt;display_order&gt;60&lt;/display_order&gt;
    &lt;grouplist&gt;
      &lt;groupid&gt;sysbuild&lt;/groupid&gt;
    &lt;/grouplist&gt;
  &lt;/category&gt;
&lt;/comps&gt;</code></pre>
<p>根据需要修改默认配置 /etc/mock/default.cfg，配置文件中config_opts['chroot_setup_cmd'] = 'install <span class="citation" data-cites="sysbuild">@sysbuild</span>' 分组名称sysbuild需要和仓库配置保持一致，参考配置如下：</p>
<pre><code>config_opts[&#39;root&#39;] = &#39;Rebuild-15-x86_64&#39;
config_opts[&#39;target_arch&#39;] = &#39;x86_64&#39;
config_opts[&#39;legal_host_arches&#39;] = (&#39;x86_64&#39;,)
config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @sysbuild&#39;
config_opts[&#39;dist&#39;] = &#39;deepin15&#39;  # only useful for --resultdir variable subst
config_opts[&#39;yum.conf&#39;] = &quot;&quot;&quot;
[main]
keepcache=1
debuglevel=2
reposdir=/dev/null
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=0
assumeyes=1
syslog_ident=mock
syslog_device=
mdpolicy=group:primary
best=1

# repos
[deepin]
name= amd64 repo 
baseurl=http://vault.centos.org/6.8/os/x86_64/ 
enabled=1 
gpgcheck=0 
&quot;&quot;&quot;</code></pre>
<p>一切准备就绪，开始使用mock 重新编译一个软件包。</p>
<pre><code>mock –init
mock –rebuild pkg.src.rpm</code></pre>
<p>小技巧：使用mock编译辅助脚本，并行编译软件包</p>
<pre><code>#！/bin/bash
pkg=$1

cat &gt; /etc/mock/$1.cfg &lt;&lt;EOF
config_opts[&#39;dist&#39;] = &#39;deepin15&#39;
config_opts[&#39;root&#39;] = &#39;$pkg&#39;
config_opts[&#39;target_arch&#39;] = &#39;x86_64&#39;
config_opts[&#39;legal_host_arches&#39;] = (&#39;x86_64&#39;,)
config_opts[&#39;chroot_setup_cmd&#39;] = &#39;install @buildsys-build&#39;
config_opts[&#39;yum.conf&#39;] = &quot;&quot;&quot;
[main]
keepcache=1
debuglevel=2
reposdir=/dev/null
logfile=/var/log/yum.log
retries=20
obsoletes=1
gpgcheck=0
assumeyes=1
syslog_ident=mock
syslog_device=
mdpolicy=group:primary
best=1

[main]
name=centos main repo
baseurl=http://10.1.10.21/server-dev/dsee-15-amd64/main/
enabled=1
priority=1
gpgcheck=0
#gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-release

&quot;&quot;&quot;
EOF

mock -r $pkg --nocheck --cleanup-after --rebuild $pkg --resultdir=/data &amp;&gt;/tmp/$1.log &amp;</code></pre>
<h2 id="深入理解rpm打包与仓库索引">深入理解RPM打包与仓库索引</h2>
<h3 id="spec文件的内容">spec文件的内容</h3>
<p>spec 文件有几个部分。第一部分是未标记的；其它部分以 %prep 和 %build 这样的行开始。</p>
<ul>
<li>spec 文件摘要部分定义了多种信息，其格式类似电子邮件消息头。</li>
<li>Summary 是一行关于该软件包的描述。</li>
<li>Name 是该软件包的基名， Version 是该软件的版本号。 Release 是 RPM 本身的版本号 ― 如果修复了 spec 文件中的一个错误并发布了该软件同一版本的新 RPM，就应该增加发行版号。</li>
<li>License 应该给出一些许可术语（如：“GPL”、“Commercial”、“Shareware”）。</li>
<li>Group 标识软件类型；那些试图帮助人们管理 RPM 的程序通常按照组列出 RPM。您可以在 /usr/share/doc/rpm-4.8.0/GROUPS 文件看到一个 Red Hat 使用的组列表</li>
<li>Source0 、 Source1 等等给这些源文件命名（通常为 tar.gz 文件）。 %{name} 和 %{version} 是 RPM 宏，它们扩展成为头中定义的 rpm 名称和版本。不要在 Source 语句中包含任何路径。缺省情况下，RPM 会在 rpmbuild/SOURCES/ 中寻找文件。请将您的源文件复制到那里。</li>
<li>接下来的部分从 %description 行开始。您应该在这里提供该软件更多的描述，这样任何人使用 rpm -qi 查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。</li>
</ul>
<p>下面几部分是嵌入 spec 文件中的 shell 脚本。</p>
<ul>
<li>%prep 负责对软件包解包。在最常见情况下，您只要用 %setup 宏即可，它会做适当的事情，在构建目录下解包源 tar 文件。加上 -q 项只是为了减少输出。</li>
<li>%build 应该编译软件包。该 shell 脚本从软件包的子目录下运行，在我们这个例子里是 indent-2.2.6 目录，因而这常常与运行 make 一样简单。</li>
<li>%install 在构建系统上安装软件包。这似乎和 make install 一样简单，唯一的关键点是要把所有二进制文件安装到rpmbuild/BUILDROOT/目录。</li>
<li>%files 列出应该捆绑到 RPM 中的文件，并能够可选地设置许可权和其它信息。</li>
<li>在 %files 中，</li>
<li>可以使用 一次%defattr 来定义缺省的许可权、所有者和组；在这个示例中， %defattr(-,root,root) 会安装 root 用户拥有的所有文件，使用当 RPM 从构建系统捆绑它们时它们所具有的任何许可权。</li>
<li>可以用 %attr(permissions,user,group) 覆盖个别文件的所有者和许可权。</li>
<li>可以在 %files 中用一行包括多个文件。</li>
<li>可以通过在行中添加 %doc 或 %config 来标记文件。 %doc 告诉 RPM 这是一个文档文件，因此如果用户安装软件包时使用 –excludedocs ，将不安装该文件。您也可以在 %doc 下不带路径列出文件名，RPM 会在构建目录下查找这些文件并在 RPM 文件中包括它们，并把它们安装到 /usr/share/doc/%{name}-%{version} 。以 %doc 的形式包括 README 和 ChangeLog 这样的文件是个好主意。</li>
<li>%config 告诉 RPM 这是一个配置文件。在升级时，RPM 将会试图避免用 RPM 打包的缺省配置文件覆盖用户仔细修改过的配置。</li>
<li>警告：如果在 %files 下列出一个目录名，RPM 会包括该目录下的所有文件。通常这不是您想要的，特别对于 /bin 这样的目录</li>
<li>%changelog 记录变更日志</li>
</ul>
<h2 id="rpm签名">RPM签名</h2>
<p>创建过程可参考文档http://www.cryptnet.net/fdp/crypto/keysigning_party/en/keysigning_party.html</p>
<pre><code>列出系统中已有的密钥信息 gpg --list-keys
导出公钥,用于验证已签名的软件包或备份
gpg --armor --output RPM-GPG-KEY-CentOS-KS --export [用户ID]
导出私钥，留作做备份
gpg --armor --output private-key.csr --export-secret-keys</code></pre>
<p>RPM签名的准备工作</p>
<p>定义如下配置:</p>
<p>%_signature gpg %_gpg_path /root/.gnupg #GPG密钥位置 %_gpg_name HaiTao Pan <script type="text/javascript">
<!--
h='&#x6b;&#110;&#x6f;&#x77;&#110;&#x73;&#x65;&#x63;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#112;&#x61;&#110;&#104;&#116;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#112;&#x61;&#110;&#104;&#116;&#32;&#x61;&#116;&#32;&#x6b;&#110;&#x6f;&#x77;&#110;&#x73;&#x65;&#x63;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript> #证书UID %_gpgbin /usr/bin/gpg</p>
<pre><code>可以保存在全局配置文件/usr/lib/rpm/macros
可以保存用户自定义配置文件 $HOME/.rpmmacros ,
或执行rpm,rpmbuild命令通过 -D, –define=’MACRO EXPR’ 选项定义配置</code></pre>
<p>使用 rpmbuild 签名</p>
<p>引用配置文件中定义的配置签名</p>
<p>rpmbuild -ba --sign ~/rpmbuild/SPECS/package.spec 或通过 -D 选项定义配置 rpmbuild -D '%_gpg_name HaiTao Pan <script type="text/javascript">
<!--
h='&#x6b;&#110;&#x6f;&#x77;&#110;&#x73;&#x65;&#x63;&#46;&#x63;&#x6f;&#x6d;';a='&#64;';n='&#112;&#x61;&#110;&#104;&#116;';e=n+a+h;
document.write('<a h'+'ref'+'="ma'+'ilto'+':'+e+'" clas'+'s="em' + 'ail">'+e+'<\/'+'a'+'>');
// -->
</script><noscript>&#112;&#x61;&#110;&#104;&#116;&#32;&#x61;&#116;&#32;&#x6b;&#110;&#x6f;&#x77;&#110;&#x73;&#x65;&#x63;&#32;&#100;&#x6f;&#116;&#32;&#x63;&#x6f;&#x6d;</noscript>' -D '%_gpg_path /root/.gnupg' -D '%_gpgbin /usr/bin/gpg' -D '%_signature gpg' -ba --sign ~/rpmbuild/SPECS/package.spec</p>
<p>签名过程中会提示输入私钥密码 使用 rpm 签名</p>
<p>rpm --addsign package.rpm rpm --resign package.rpm</p>
<p>签名过程中会提示输入私钥密码 签名验证</p>
<p>rpm -K package.rpm rpm -qpi package.rpm</p>
<p>其他</p>
<p>结合 yum-utils软件包 repomanager 等工具可以辅助管理仓库内的rpm文件。</p>
<h2 id="参考文档">参考文档</h2>
<ul>
<li>http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch11s04s02.html</li>
<li>http://yum.baseurl.org/wiki/RepoCreate</li>
<li>http://fedoraproject.org/wiki/Docs/Drafts/BuildingPackagesGuide</li>
<li>http://fedoraproject.org/wiki/Packaging/Guidelines</li>
<li>http://fedoraproject.org/wiki/ParagNemade/PackagingNotes</li>
<li>http://www.rpm.org/max-rpm/</li>
</ul>
</body>
</html>
