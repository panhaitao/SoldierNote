<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="如何制作一个发行版">如何制作一个发行版</h1>
<p>作为一个和GNU/Linux系统打交道多年，靠玩GNU/Linux混碗饭吃的家伙，不算新人，也谈不上老兵的，在一些国内发行版厂商工作过，也有过一段运维工作的经历，结合工作中遇见些大大小小的坑，想谈一谈如何创建一个GNU/Linux发行版。</p>
<h2 id="前提条件">前提条件</h2>
<p>本文只是梳理创建一个发行版的流程，只会谈到设计的工具，不会谈到软件开发和打包细节问题，发行版更重要的是一种管理模式，如何有效合理的维护，分发软件，下面的列出的是个人觉得发行版维护人员需要具备的基础知识：</p>
<ul>
<li>首先对GNU/Linux有足够的兴趣，熟悉主流发行版本的安装和基础使用</li>
<li>有源码包的编译，安装的基础和相关工具的使用例如 <code>gcc，clang/llvm，autotools，make，camke，qmake</code></li>
<li>熟悉版本控制工具的使用，典型的比如：<code>git，svn</code></li>
<li>熟悉deb，rpm等常见包格式的制作,了解软件仓库的概念</li>
<li>具备一定的软硬件基础知识，操作系统与应用软件的区别和基础概念</li>
<li>比如了解何为bios或者uefi,熟悉启动引导过程及其相关工具的基本配置和使用，比如grub，isolinux</li>
<li>有过制作LFS的经历更佳</li>
</ul>
<h2 id="制定合理的计划">制定合理的计划</h2>
<p>在学生时代，各种教材一直在强调，程序=算法+数据结构，在实际工作中，程序+工程管理才是软件开发的全部，没有良好的工程管理，有再好的算法，有再严谨的数据结构，也做不好软件，操作系统版本开发也一样.</p>
<ul>
<li>定义一个合理的目标，要定位这个版本是面向哪些用户群体，提供哪些功能，投入多少人力物力</li>
<li>定义版本的生命周期：和软件开发，做应用项目一样，一个版本同样有它的生命周期，比如规划阶段，开发阶段，维护阶段，支持结束等一个完整的生命周期，定义合理的版本生命周期，有始有终是重中之重！</li>
<li>定义软件包命名方式：总体原则就是，创建一个团队内统一约定并且遵循的命名方式。</li>
<li>定义基础工具链: （kernel，libc，gcc，binutils）这些个核心包是操作系统版本的基石</li>
</ul>
<h2 id="linux发行版的工作流程">LINUX发行版的工作流程</h2>
<p>所有发行版大体都遵循这个流程：源码版本控制-&gt; 打包制作安装包 -&gt; 归档入库 -&gt; 制作安装介质.创建一个GNU/Linux发行版，核心关注点个人理解就是三个，安装包，仓库，安装介质：</p>
<ul>
<li>安装包：这项的关注点是如何从源码生成安装包，保证安装包间的依赖关系正确</li>
<li>仓库：这项的关注点是如何把安装包导入仓库，并保证仓库中索引和数据一致正确</li>
<li>安装介质：这项的关注点是从仓库同步获取最新的软件包，制作成可用可引导介质，比如安装光盘，安装U盘</li>
</ul>
<h2 id="其他细节与规范">其他细节与规范：</h2>
<ul>
<li>使用版本控制工具来管理源码，源码的修改提交一定要是使用版本控制工具，不要觉得使用版本控制工具是多余的步骤，使用版本控制可以方便的完成跟踪，评审，甚至回滚等操作；</li>
<li>打包制作安装包，从源码制作安装包：</li>
<li>一个细节就是尽量每次都能在一个干净的环境下构建</li>
<li>另外一个细节就是软件包每次构建的修订号要保持保持持续增加，就算是代码回滚，修订号依然要保持+1,很多时候的混乱根源就是从打包开始；</li>
<li>归档入库 -&gt; 制作安装介质，向仓库导入软件包，有个原则，就是仓库内的软件包原则上只能升级，不能覆盖仓库里同版本的软件包，不能随意降级软件包版本，在生成安装介质的时候，一定要清空本地构建环境，每次都从仓库获取最新软件包；</li>
</ul>
<h2 id="聊聊那些年踩过的坑">聊聊那些年踩过的坑</h2>
<p>好多时候，我们看到的是成功，下面我只谈工作中实际接触到的失败案例或错误的维护方式，作为踩过的坑：</p>
<ul>
<li>开发阶段主版本号一确定，只能修订，不可再变更，牵一发而动全身，一但升级某个基础工具链软件包，几乎将导致整个仓库需要全部重新构建，甚至会带来很多潜在的问题。</li>
<li>曾经工作在一个技术领导在带领开发一个操作系统版本的时候，在研发人员基本是个位数的情况下，没有计划，无休止的添加新功能，频繁的发布版本，最后这个项目被公司中止了，因为从上到下，都陷入了一种不知道要做成什么样子，不知道做到成么程度的迷茫状态，</li>
<li>以曾经工作过的北京团队为例，曾经有一个产品是以debian8为上游，技术领导曾计划将原有内核从3.16升级到4.x版本，所幸没有升级，不然就是一场灾难，</li>
<li>以打过交道的上海某团队为例，在开发周期内，内核版本一路从3.10升级到4.4，并且在开发仓库同时存在多个并行版本<code>4.4.32, 4.4.69, 4.4.71</code>，版本迟迟不能发布</li>
<li>打包是维护发行版很重要的一个环节，很多开发人员能很好的的完成功能，却不能提交一个高质量的debian格式的源码包，以上海团队为例。提交的debian格式的内核源码包，重新构建时，存在如下两个问题，提交到Gitlab的 <code>linux-4.4.32</code> 的deb格式的源码包重新构建时，存在如下问题：</li>
<li>缺失编译依赖<code>firmware-amd-graphics</code></li>
<li><p>构建过程中存在如下错误:</p>
<pre><code>firmware/radeon/RV710_pfp.bin.gen.S: Assembler messages:
firmware/radeon/RV710_pfp.bin.gen.S:5: 
错误：file not found: /opt/deb-build/linux-4.4.32/firmware/radeon/RV710_pfp.bin
/opt/deb-build/linux-4.4.32/scripts/Makefile.build:294: 
recipe for target &#39;firmware/radeon/RV710_pfp.bin.gen.o&#39; failed
make[6]: *** [firmware/radeon/RV710_pfp.bin.gen.o] Error 1</code></pre>
<p>不要幻想过度依赖的自动化平台来解决效率问题，基础工作没有做好，根本就无从谈起自动化，这种质量的软件包在自动构建流程是跑不通的，一个高质量的debian格式的源码包，最基本的要求是要满足编译依赖，运行依赖正确，可反复重新构建。</p></li>
</ul>
</body>
</html>
