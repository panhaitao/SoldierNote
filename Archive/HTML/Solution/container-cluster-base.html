<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="使用etcdflanneldocker搭建一个跨物理机的容器集群">使用etcd,flannel,docker搭建一个跨物理机的容器集群</h2>
<p>大致步骤是：</p>
<ul>
<li>启动Etcd后台进程</li>
<li>在Etcd里添加Flannel的配置</li>
<li>启动Flanneld后台进程</li>
<li>配置Docker的启动参数</li>
<li>重启Docker后台进程</li>
</ul>
<p>简单的说flannel做了三件事情：</p>
<ol type="1">
<li>数据从源容器中发出后，经由所在主机的docker0虚拟网卡转发到flannel0虚拟网卡，这是个P2P的虚拟网卡，flanneld服务监听在网卡的另外一端。 Flannel也是通过修改Node的路由表实现这个效果的。</li>
<li>源主机的flanneld服务将原本的数据内容UDP封装后根据自己的路由表投递给目的节点的flanneld服务，数据到达以后被解包，然后直接进入目的节点的flannel0虚拟网卡，然后被转发到目的主机的docker0虚拟网卡，最后就像本机容器通信一样由docker0路由到达目标容器。</li>
<li>使每个结点上的容器分配的地址不冲突。Flannel通过Etcd分配了每个节点可用的IP地址段后，再修改Docker的启动参数。“--bip=X.X.X.X/X”这个参数，它限制了所在节点容器获得的IP范围。</li>
</ol>
<h2 id="etcd-和flannel">etcd 和flannel</h2>
<pre><code>etcdctl -C http://10.1.11.168:2379 set /flannel/network/config &#39;{&quot;Network&quot;: &quot;192.168.0.0/16&quot;}&#39;</code></pre>
<h2 id="docker-和-flannel">docker 和 flannel</h2>
<ul>
<li><p>flanneld.service</p>
<p>ExecStartPost=/usr/libexec/flanneld/mk-docker-opts.sh -k DOCKER_NETWORK_OPTIONS -d /run/flannel/docker.env</p></li>
<li><p>docker.service</p>
<p>[Service] EnvironmentFile=-/run/flannel/docker.env</p></li>
</ul>
</body>
</html>
