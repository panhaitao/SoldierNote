<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="基于ca签名的双向证书认证方式">基于CA签名的双向证书认证方式</h1>
<p>基于CA签名的双向证书的生成过程如下：</p>
<p>1. 创建CA根证书</p>
<p>2. 为kube-apiserver生成一个证书，并用CA证书进行签名，设置启动参数</p>
<ol start="3" type="1">
<li>根据k8s集群数量，分别为每个主机生成一个证书，并用CA证书进行签名，设置相应节点上的服务启动参数</li>
</ol>
<h2 id="集群架构">集群架构</h2>
<p>k8s-master: 运行服务 apiserver, controllerManager, scheduler</p>
<p>k8s-node1 : 运行服务 kubelet, proxy</p>
<p>k8s-node2 : 运行服务 kubelet, proxy</p>
<p>k8s-node3 : 运行服务 kubelet, proxy</p>
<h2 id="生成证书">生成证书</h2>
<h3 id="创建集群的root-ca">创建集群的root CA</h3>
<p>生成CA、私钥、证书</p>
<p><code>   openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ca.key -out ca.crt -subj &quot;/CN=k8s-master&quot;  </code></p>
<p><code>   CA的CommonName 需要和运行kube-apiserver服务器的主机一直</code></p>
<h3 id="创建apiserver的私钥服务端证书">创建apiServer的私钥、服务端证书</h3>
<p>创建证书配置文件 /etc/kubernetes/openssl.cnf ，在alt_names里指定所有访问服务时会使用的目标域名和IP； 因为SSL/TLS协议要求服务器地址需与CA签署的服务器证书里的subjectAltName信息一致</p>
<pre><code>[req]
req_extensions = v3_req
distinguished_name = req_distinguished_name
[req_distinguished_name]
[ v3_req ]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names
[alt_names]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster.local
DNS.5 = localhost
DNS.6 = centos-master
IP.1 = 127.0.0.1
IP.2 = 10.254.0.1
IP.3 = 10.1.10.238</code></pre>
<p>最后两个IP分别是clusterIP取值范围里的第一个可用值、master机器的IP。 k8s会自动创建一个service和对应的endpoint，来为集群内的容器提供apiServer服务； service默认使用第一个可用的clusterIP作为虚拟IP，放置于default名称空间，名称为kubernetes，端口是443； openssl.cnf里的DNS1~4就是从容器里访问这个service时会使用到的域名。</p>
<p>创建分配给apiServer的私钥与证书</p>
<pre><code>cd /etc/kubernetes/ca/
openssl genrsa -out server.key 2048
openssl req -new -key server.key -out server.csr -subj &quot;/CN=k8s-master&quot; -config ../openssl.cnf
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 9000 -extensions v3_req -extfile ../openssl.cnf</code></pre>
<p>验证证书： openssl verify -CAfile ca.crt server.crt</p>
<h3 id="创建访问apiserver的各个组件使用的客户端证书">创建访问apiServer的各个组件使用的客户端证书</h3>
<pre><code>for f in client k8s-node1 k8s-node2 k8s-node3  
do
    KEY_NAME=$f
    if [[ $KEY_NAME == client ]];then
      #HOST_NAME=k8s-master
      HOST_NAME=$KEY_NAME 
    else
      HOST_NAME=$KEY_NAME
    fi
      
    openssl genrsa -out $KEY_NAME.key 2048
    openssl req -new -key $KEY_NAME.key -out $KEY_NAME.csr -subj &quot;/CN=$HOST_NAME&quot;
    openssl x509 -req -days 9000 -in $KEY_NAME.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out $KEY_NAME.crt 
done</code></pre>
<p>注意设置CN(CommonName) 要在k8s集群中（client k8s-node1 k8s-node2 k8s-node3）域名解析生效</p>
<p>验证证书： openssl verify -CAfile ca.crt *.crt</p>
<h2 id="创建-etckuberneteskubeconfig-模板">创建 /etc/kubernetes/kubeconfig 模板</h2>
<pre><code>kubectl config set-cluster k8s-cluster --server=https://10.1.10.238:6443 --certificate-authority=/etc/kubernetes/ca/ca.crt 
kubectl config set-credentials default-admin --certificate-authority=/etc/kubernetes/ca/ca.crt --client-key=/etc/kubernetes/ca/client.key --client-certificate=/etc/kubernetes/ca/client.crt
kubectl config set-context default-system --cluster=k8s-cluster --user=default-admin
kubectl config use-context default-system
kubectl config view &gt; /etc/kubernetes/kubeconfig

apiVersion: v1
clusters:
- cluster:
    certificate-authority: /etc/kubernetes/ca/ca.crt
    server: https://10.1.10.238:6443
  name: k8s-cluster
contexts:
- context:
    cluster: k8s-cluster
    user: default-admin
  name: default-system
current-context: default-system
kind: Config
preferences: {}
users:
- name: default-admin
  user:
    client-certificate: /etc/kubernetes/ca/client.crt
    client-key: /etc/kubernetes/ca/client.key</code></pre>
<p>提供给各个客户端组件作为启动参数: &quot;--kubeconfig=/etc/kubernetes/kubeconfig&quot;</p>
<h2 id="集群分发证书">集群分发证书</h2>
<ol type="1">
<li>假设controllerManager、scheduler 和 apiservers运行在同一台主机上，因此CommonName 为k8s-master</li>
</ol>
<p>最后生成的证书</p>
<pre><code>client.key client.crt       : 提供给运行在k8s-master主机上的controllerManager、scheduler服务和kubectl工具使用   
k8s-node1.key k8s-node1.crt : 提供给运行在k8s-node1主机上的kubelet, proxy服务使用
k8s-node2.key k8s-node2.crt ：余下类同 
...</code></pre>
<p>每台主机存放的证书位置如下，和kubeconfig配置中需要保持一致:</p>
<ul>
<li>/etc/kubernetes/kubeconfig</li>
<li>/etc/kubernetes/ca/ca.crt</li>
<li>/etc/kubernetes/ca/client.crt</li>
<li>/etc/kubernetes/ca/client.key</li>
</ul>
<p>因为CA在k8s-master主机上，直接使用client.key client.crt, k8s-node主机需要把对应证书拷贝到对应目录和重命名文件， 以k8s-node1主机为例:</p>
<p><code>   from CA: /etc/kubernetes/ca/ca.crt &gt;          k8s-node1 主机: /etc/kubernetes/ca/ca.crt</code><br />
<code>   from CA: /etc/kubernetes/ca/k8s-node1.crt -&gt;  k8s-node1 主机: /etc/kubernetes/ca/client.crt</code><br />
<code>   from CA: /etc/kubernetes/ca/k8s-node1.key -&gt;  k8s-node1 主机: /etc/kubernetes/ca/client.key</code><br />
<code>   ...余下类同</code></p>
<ul>
<li>系统中导入可信CA根证书</li>
</ul>
<p>1.安装 ca-certificates package: yum install ca-certificates</p>
<p>2.启用dynamic CA configuration feature: update-ca-trust force-enable</p>
<p>3.新增加一个可信的根证书 cp /etc/kubernetes/ca/ca.crt /etc/pki/ca-trust/source/anchors/</p>
<p>4.更新列表: update-ca-trust extract</p>
<h2 id="参考">参考</h2>
<p><a href="https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/" class="uri">https://kubernetes.io/docs/tasks/access-application-cluster/configure-access-multiple-clusters/</a></p>
<p><a href="https://kubernetes.io/docs/admin/authentication/#authentication-strategies" class="uri">https://kubernetes.io/docs/admin/authentication/#authentication-strategies</a></p>
<p><a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/#openssl" class="uri">https://kubernetes.io/docs/concepts/cluster-administration/certificates/#openssl</a></p>
</body>
</html>
